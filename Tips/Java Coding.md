1. **Naucz się sztuki skrótów klawiszowych w IDE**.
2. **Używaj StringBuilder przy łączeniu dwóch lub więcej stringów**. Zmniejsza użycie pamięci i poprawia wydajność.
3.  **Wykorzystuj gdzie się da rozszerzoną pętle for-each**.
4. **Strumienie API Java to potężne narzędzie do przetwarzania danych.    
5. **Unikaj NullPointerException za pomocą Optional**.
6. **Korzystaj z Lombok aby unikać Boilerplate Code.
7. **Break i Continue pomagają pisać bardziej wydajne pętle.
8. **Korzystaj mądrze z wzorca projektowego Singleton.
9. **Jeśli potrzebujesz zwrócić strukturę danych, ale chcesz mieć pewność o jej niemutowalności - zastosuj `List.of()` lub `Collections.unmodifiableList`.
10. **Potrzebujesz posortować listę obiektów? `Comparator.comparing` sprawia, że sortowanie jest proste i czyste.**
11. **Preferuj interfejsy zamiast abstrakcyjnych klas.
12. **Korzystaj z statycznych metod fabrycznych zamiast konstruktorów.
13. **Używaj wstrzykiwanie zależności (DI) dla lepszej testowalności.
14. **Enum jest lepszym wyborem od stałych zmiennych.
15. **Korzystaj z try z zasobami - automatycznie zamyka zasób, co pozwala unikać błędów**.
16. **Referencje do metod `Person::getAge` wspomagają czytelność strumieni w Javie.
17. **Słowo kluczowe `final` pozwala na zabezpieczenie podmiotu przed modyfikacją.
18. **Implementacja `cache` radykalnie poprawia wydajność aplikacji, np. przy obliczeniach.
19. **Zawsze korzystaj z @Override**.
20. **Znaki diamentu `<>` pozwala tworzyć lepszy kod.
21. **Używaj statycznych importów dla lepszej czytelności.
22. **Korzystaj z `Map.of()` i `List.of()` dla większego bezpieczeństwa struktur danych.** 
23. **Poznaj i zrozum kontrakt `equals` i `hasCode` dla typów danych Hash (np. HashMap).
24. **Korzystaj z wbudowanych funkcyjnych interfejsów `Function`, `Predicate`, `Supplier` itd.**
25. **Dla programowania asynchronicznego, używaj `CompletableFuture`.
26. **Do rozwiązywania problemów z czasem i datą, stworzony został pakiet `java.time`.
27. **Obecność polimorfizmu, pozwala pisać czytelny kod.
28. **Zrozum różnicę między == i equals (pierwszy porównuje referencje, drugi wartości obiektów).
